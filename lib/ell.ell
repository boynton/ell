;
; macros and non-core definitions to the Ell language
;

;;
;; shortcuts for accessing lists
;;
(define (caar p) (car (car p)))
(define (cadr p) (car (cdr p)))
(define (cdar p) (cdr (car p)))
(define (cddr p) (cdr (cdr p)))
(define (caaar p) (car (car (car p))))
(define (caadr p) (car (car (cdr p))))
(define (cadar p) (car (cdr (car p))))
(define (caddr p) (car (cdr (cdr p))))
(define (cdaar p) (cdr (car (car p))))
(define (cdadr p) (cdr (car (cdr p))))
(define (cddar p) (cdr (cdr (car p))))
(define (cdddr p) (cdr (cdr (cdr p))))
(define (caaaar p) (car (car (car (car p)))))
(define (caaadr p) (car (car (car (cdr p)))))
(define (caadar p) (car (car (cdr (car p)))))
(define (caaddr p) (car (car (cdr (cdr p)))))
(define (cadaar p) (car (cdr (car (car p)))))
(define (cadadr p) (car (cdr (car (cdr p)))))
(define (caddar p) (car (cdr (cdr (car p)))))
(define (cadddr p) (car (cdr (cdr (cdr p)))))
(define (cdaaar p) (cdr (car (car (car p)))))
(define (cdaadr p) (cdr (car (car (cdr p)))))
(define (cdadar p) (cdr (car (cdr (car p)))))
(define (cdaddr p) (cdr (car (cdr (cdr p)))))
(define (cddaar p) (cdr (cdr (car (car p)))))
(define (cddadr p) (cdr (cdr (car (cdr p)))))
(define (cdddar p) (cdr (cdr (cdr (car p)))))
(define (cddddr p) (cdr (cdr (cdr (cdr p)))))

;; defmacro is a more convenient form. This should get pushed down as a primitive
(define-macro (defmacro expr)
  `(define-macro ~(cadr expr) (lambda (expr) (apply (lambda ~(caddr expr) ~@(cdddr expr)) (cdr expr)))))

;; should be a primitive
(defmacro def (name value)
  `(define ~name ~value))

;; shorthand for define function, should be a primitive
(defmacro defn (name args & body)
  `(define ~name (lambda ~args ~@body)))

;; or returns the first non-false item in the list
(defmacro or ops
  (if (empty? ops)
      false
      (let loop ((c (car ops)) (r (cdr ops)))
        (if (empty? r)
            c
            `(let ((tmp ~c)) (if tmp tmp ~(loop (car r) (cdr r))))))))

;; and returns the first false item in the list, or the last item in the list of all are non-false
(defmacro and ops
  (if (empty? ops)
      true
      (let loop ((c (car ops)) (r (cdr ops)))
        (if (empty? r)
            c
            `(let ((tmp ~c)) (if (not tmp) false ~(loop (car r) (cdr r))))))))

;; returns a list consisting of the first N items of another list
(defn take (n lst)
  (if (or (empty? lst) (<= n 0))
      '()
      (cons (car lst) (take (- n 1) (cdr lst)))))

;;
;; Map a function over a list. Each argument is list, and for N lists, the function is called
;; with the N elements of the lists as args, then again for the next set of args, etc.
;;
(defn map (fun first & rest)
  (defn map1 (fun lst)
    (if (empty? lst) '()
        (cons (fun (car lst)) (map1 fun (cdr lst)))))
  (defn any-empty? (list-of-lists)
    (if (empty? list-of-lists)
        false
        (if (empty? (car list-of-lists))
            true
            (any-empty? (cdr list-of-lists)))))
  (defn mapn (fun arglist)
    (let loop ((result '()) (args arglist))
      (if (any-empty? args)
          (reverse result)
          (loop (cons (apply fun (map1 car args)) result) (map1 cdr args)))))
  (if (empty? rest)
      (map1 fun first)
      (mapn fun (cons first rest))))

;;
;; i.e. (validated-struct {x: 1} '(x: y:))
(defn validated-struct (val name fields)
  (if (empty? fields)
      val
      (if (null? ((car fields) val))
          (error "cannot convert to " name ", missing field: " (car fields))
          (validated-struct val name (cdr fields)))))

;;
;; Defines a struct type by emitting a constructor and a predicate
;; The fields are a sequence key/value pairs, and the resulting constructor limits
;; the arguments to those indicated, with the given default values
;; i.e.
;;   (defstruct point x: 0 y: 0) ; this defines a struct with an and a y field with default value of 0
;;   (point) => #point{x: 0, y: 0}
;;   (point? (point)) => true
;;   (point x: 23 y: 57) => #point{x: 23, y: 57}
;;   (point x: 23 y: 57 z: 100) => error("z: bad keyword parameter")
;;   (point-fields) -> (x: y:)
;;You can get the raw struct from it:
;;   (struct #point{x: 23, y: 57}) => {x: 23, y: 57}
;;
(defmacro defstruct (sym & fields)
  (defn extract-keys (args)
    (let loop ((keys '()) (remaining args))
      (if (empty? remaining)
          (reverse keys)
          (let ((sym (car remaining)))
            (if (keyword? sym)
                (loop (cons sym keys) (cddr remaining))
                (loop keys (cdr remaining)))))))
  (let ((keys (extract-keys fields)) (typesym (symbol "<" sym ">")))
    `(do
       (defn ~sym args (instance ~typesym (apply struct (concat '~fields (normalize-keyword-args args ~@keys)))))
       (defn ~(symbol sym "?") (o) (equal? (type o) ~typesym))
       (defn ~(symbol sym "-fields") () '~keys)
       (defn ~(symbol "as-" sym) (o)
         (instance '~typesym (validated-struct o '~typesym '~keys)))
       '~typesym)))

;;
;; create a type based on some other (non-struct) type, by providing the predicate
;; i.e. 
;;   ? (deftype foo (s) (and (string? s) (< (string-length s) 3)))
;;   = <foo>
;;   ? (foo "abc")
;;    *** not a valid <foo>: "abc"
;;   ? (foo "ab")
;;   = #foo{value: "ab"}
;;   ? (foo? (foo "ab"))
;;   = true
;; 
;; This aggregates the parameter, so the result is a struct, but correctness is determined by the
;; predicate, instead of matching fields of another struct like defstruct does.
;;
(defmacro deftype (sym args & predicate-body)
  (let ((typesym (symbol "<" sym ">"))
        (arg (car args)))
    `(do
       (defn ~(symbol sym "?") (o)
         (and (struct? o) ((lambda ~args ~@predicate-body) (value: o)) true))
       (defn ~sym ~args
         (if (not ~@predicate-body)
             (error ~(string "not a valid " typesym ": ") (write-to-string ~arg)))
         (instance ~typesym ~(car args)))
       ~typesym)))

;;
;; generic functions dispatch to methods based on argument type
;;
(defstruct generic-function name: "" args: '() methods: {})

;; All generic function definitions are stored in this dynamic variable
(def *genfns* {})

;;
;; declares the specified symbol to be a generic dispatch function for the given arguments
;;
(defmacro defgeneric (name args)
  (let ((gf (generic-function name: name args: args)))
    (put! *genfns* name gf)
    `(define ~name (lambda ~args ((get-method '~name (list ~@args)) ~@args)))))

;;
;; Called by the generic function.
;; Given the generic function symbol and an actual argument list, return the metching method
;; This does not do any inheritance, just exact type matching.
;; This function needs optimizing!
;;
;; BUG: doesn't work with either rest (&) or keyword args
;;
(defn get-method (sym args)
  (define (combos lst)
    (if (empty? lst)
        (list '())
        (let ((first (car lst))
              (rest (combos (cdr lst))))
          (concat
           (map (lambda (r) (cons first r)) rest)
           (map (lambda (r) (cons <any> r)) rest)))))
  (define (combos-as-strings lst) (map (lambda (x) (apply string x)) (combos lst)))
  (define gf (get *genfns* sym))
  (if (null? gf)
      (error "Not a generic function: " sym))
  (let ((methods (methods: gf)) (arg-types (map type args)))
    ;;to do: memoize the result based on arg-types
    (let loop ((keys (combos-as-strings arg-types)))
      (if (empty? keys)
          (error "Generic function " sym " has no matching method for: " arg-types)
          (let ((key (string (car keys))))
            (let ((meth (get methods key)))
              (if (function? meth)
                  meth
                  (loop (cdr keys)))))))))


;;
;; Called by defmethod
;;

(defn methods (sym)
  (let ((gf (get *genfns* sym)))
    (if (not (null? gf))
        (map car (struct->list (methods: gf))))))

;;
;; defmethod - defines a method for the generic function with the specialized types
;;
(defmacro defmethod (sym specialized-args & body)
  (defn add-method (sym specialized-args fun)
    (define (method-arg-types args)
      (let loop ((remaining args) (result '()))
        (if (empty? remaining)
            (reverse result)
            (let ((item (car remaining)))
              (loop (cdr remaining) (if (symbol? item) (cons <any> result) (cons (cadr item) result)))))))
    (define (method-arg-names args)
      (map (lambda (item) (if (symbol? item) item (car item))) args))
    (let ((gf (get *genfns* sym)))
      (if (null? gf)
          (error "Not a generic function: " sym))
      (letrec ((methods (methods: gf))
               (types (method-arg-types specialized-args))
               (names (method-arg-names specialized-args))
               (key (apply string types)))
        (put! methods key fun)
        sym)))
  (let ((names (map (lambda (item) (if (symbol? item) item (car item))) specialized-args))
        (gf (get *genfns* sym)))
    (if (defined? sym)
        (if (not (generic-function? gf))
            (error sym " is already defined to something other than a generic function"))
        (error sym " is is not defined as a generic function"))
    `(add-method '~sym '~specialized-args (lambda ~names ~@body))))

;;
;; For - list comprehension. Creates nested loops over the given sequences
;;
;; ? (for ((x '(a b c)) (y '(1 2 3))) [x y])                                     
;; = ([a 1] [a 2] [a 3] [b 1] [b 2] [b 3] [c 1] [c 2] [c 3])
;;
(defmacro for (bindings & body)
  (defn expand-for-loop (sym init final-body prev-final prev more-bindings)
    (let ((loop (symbol "loop-" sym))
          (remaining (symbol "remaining-" sym))
          (result (symbol "result-" sym)))
      (if (empty? more-bindings)
          (let ((final-result (if (symbol? prev)
                                  `(if (empty? ~(symbol "remaining-" prev))
                                       ~(symbol "result-" prev)
                                       (~(symbol "loop-" prev) (cdr ~(symbol "remaining-" prev)) (concat ~(symbol "result-" prev) ~result))) result)))
            (let ((body `(if (empty? ~remaining) ~final-result (~loop (cdr ~remaining) (concat ~result ~prev-final)))))
              `(let ~loop ((~remaining ~init) (~result '())) ~body)))
          (let ((body (expand-for-loop (caar more-bindings) (cadar more-bindings) result final-body sym (cdr more-bindings))))
            `(let ~loop ((~remaining ~init) (~result '())) ~body)))))
  (if (empty? bindings)
      `((lambda () ~@body))
      (let ((final-body (list 'list (cons `(lambda (~@(map car bindings)) ~@body) (map (lambda (binding) `(car ~(symbol "remaining-" (car binding)))) bindings))))
            (binding (car bindings))
            (more (cdr bindings)))
        (expand-for-loop (car binding) (cadr binding) final-body final-body false more))))

;;
;; placeholder -> this will be a lazy sequence at some point
;;
(defn range args
  (defn range-aux (start end step)
    (let loop ((i start) (result '()))
      (if (>= i end)
          (reverse result)
          (loop (+ i step) (cons i result)))))
  (let ((argc (length args)))
    (cond
      ((= argc 0)
       (error "infinite sequences not yet supported"))
      ((= argc 1)
       (range-aux 0 (car args) 1))
      ((= argc 2)
       (range-aux (car args) (cadr args) 1))
      ((= argc 3)
       (range-aux (car args) (cadr args) (caddr args)))
      (true
       (error "wrong number of args to range: " argc)))))

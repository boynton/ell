(use assert)

;; ranges. These ar not lazy, and thus of limited use
(assert-equal '(0 1 2 3 4 5 6 7 8 9) (range 10))
(assert-equal '(1 2 3 4 5 6 7 8 9) (range 1 10))
(assert-equal '(1 3 5 7 9) (range 1 10 2))
(assert-equal '(-4 -3 -2 -1 0 1 2 3 4) (range -4 5))
(assert-equal '(4 3 2 1 0 -1 -2 -3 -4) (range 4 -5 -1))

(let ((x '()))
   (dorange (i 5) (set! x (cons i x)))
   (assert-equal '(4 3 2 1 0) x " dorange"))

(let ((x '()))
   (dolist (i '(0 1 2 3 4)) (set! x (cons i x)))
   (assert-equal '(4 3 2 1 0) x (string " dolist: " x)))

(let ((x '()))
   (for (i 0 5) (set! x (cons i x)))
   (assert-equal '(4 3 2 1 0) x (string " for loop on range: " x)))

(let ((x '()))
   (for (i 0 5 2) (set! x (cons i x)))
   (assert-equal '(4 2 0) x (string " for loop on range with step: " x)))

(let ((x '()))
   (for (i '(0 1 2 3 4)) (set! x (cons i x)))
   (assert-equal '(4 3 2 1 0) x (string " for loop over list: " x)))

(let ((x '()))
   (for (i [0 1 2 3 4]) (set! x (cons i x)))
   (assert-equal '(4 3 2 1 0) x (string "for loop over a vector: " x)))


(let ((x '()) (ref {x: 1 y: 2 z: 3}))
  ;;note: the order of the keys is random, so we cannot simply compare the resulting list with any constant
  (for (i ref) (set! x (cons i x)))
  (assert (and (= 3 (length x)) (list? (car x)) (= 2 (length (car x)))) "for loop over a struct (1)")
  (assert-equal (apply struct (flatten x)) ref "for loop over a struct (2)"))

(let ((x '()))
   (for (i "abc") (set! x (cons i x)))
   (assert-equal '(#\c #\b #\a) x (string "for loop over a string: " x)))

;(println "!! " (catch (for () '())))

(println "[for_range_test OK]")
